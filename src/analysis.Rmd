---
title: "CLB Business Licensing Trends Analysis"
output:
  html_notebook: default
  pdf_document: default
---

## Prerequisites 

Make sure you have [tidyverse](http://tidyverse.org/), [lubridate](https://github.com/hadley/lubridate), and [prophet](https://facebookincubator.github.io/prophet/) libraries installed in your R enviornment before we begin.

```{r}
library(tidyverse)
library(lubridate)
library(purrr)
library(prophet)
```

I also import some commonly used functions and code for analyses.

```{r}
source("../R/utils.R")
```

# Analysis request from management

> "Anything about seasonal [business licensing] fluctuation? For instance, the licenses in the latter half of the year generally take longer because there is a lot of construction going on."

We will be importing the latest Business Licensing dataset available from City of Long Beach / Financial management and first analyze trends for Active licenses. This analysis will include all licensing activity (new, issued, renewed).

Afterward, we will see if there is any time series trends for how many days it takes to issue a license to a new applicant. 

## Import the business licensing dataset

```{r}
business_licenses <- read_csv("../data/raw/business_licenses.csv",
                              col_types = cols(
                                servicedate = col_date("%Y-%m-%d %H:%M:%S"),
                                startdate = col_date("%Y-%m-%d %H:%M:%S"),
                                milestonedate = col_date("%Y-%m-%d %H:%M:%S"),
                                load_date = col_datetime(),
                                bid_code = col_character(),
                                licensecat = col_character(),
                                zip = col_character()
                              ))
```

## Data cleanup

### Filtering out Inactive licenses

As per Bretty Yakus, an **Active** business license is defined by Financial Management (FM) as business licenses that have a status of:

  * Active
  * CollcInBus
  * Expired (a licensee might become reactivated or go into collections)
  * Pending
  * Conditionl

Thereby, **Inactive** licenses are those that are not of the above statuses.

Create a new dataframe for "Active" licenses.

```{r}

active_licstatus = c('Active', 'CollcInBus', 'Expired', 'Pending', 'Reactivate', 'Conditionl')
active_milestones = c('Issued', 'Renewed', 'Collections', 'Pre-Collections', 'Pre-Renew', 'Renewed')

active_licenses <- business_licenses %>%
  filter(licstatus %in% active_licstatus & milestone %in% active_milestones)
```

### Analysis date range

In order to get a set of reliable data, we need to get a daily summary of Active/Issued business licenses. Note that we are filtering out all licenses before **August 2015**. This is due to the new version of the LMR/Hansen module foe business licenses going online August 2015. Prior to this system upgrade milestones weren't track electronically for applications - thus not having an electonic log to check when a license was first issued.

```{r}
analysis_date_start <- as_date("2015-08-01")
analysis_date_end <- as_date("2017-02-28") # last previous full month
```

### Get a daily count of Active/Issued licenses

Clean up steps executed to count our data: 

1. Filters milesonedate to be in the range of our defined analysis date range.
2. Summarises the dataframe by counting the number of observations (y) grouped by the desired date.
3. Log-transforms the y variable for us to more clearly see increases in variation over time. This is especially important for exponentiall growing trends.
3. Renames our date/milestone date and count variable to **ds** and **y** respectively. The `prophet` library expects these named parameters to create our forecasting model.

```{r}
daily_count <- active_licenses %>% 
  df_daily_count(analysis_date_start, analysis_date_end, target_date = active_licenses$milestonedate)
```

We are using the **milestonedate** in our analysis. The milestone date is used by Hansen as the log date/time stamp to capture capture events for a business licensee.

## Forecasting

### Create the model

We fit the model by passing in the historical dataframe and instantiating a new `Prophet` object. I have decided to not fit weekly seasonality as there was a lot of noise in our forecasted data.

```{r}
m <- prophet(daily_count, weekly.seasonality = FALSE)
```

### Predicting activity

Predictions are then made on a dataframe with a column named `ds` containing the dates for which predictions are to be made. The `make_future_dataframe` function takes the model object and a number of periods to forecast and produces a suitable dataframe. By default it will also include the historical dates so we can evaluate in-sample fit.

We will now make predictions with the model for the next year (or 365 periods).

```{r}
future <- make_future_dataframe(m, periods = 365)
forecast <- predict(m, future)
```

The forecast can be visualized using the `plot` function.

```{r}
plot_forecast(m,
              forecast,
              xlabel = 'Year',
              ylabel = "Log Count")
```


We can use the `prophet_plot_components` function to see the forecast components. By default you'll see the trend, yearly, seasonality, and weekly seasonality of the time series.

```{r}
prophet_plot_components(m, forecast)
```

It appears that there is more overall licensing activity during the spring and summer months.

## Export data

Export our processed dataframes for archival and sharing purposes.

```{r}
write_csv(daily_count, "../data/processed/all_licenses_daily_count.csv")
write_csv(forecast, "../data/processed/all_licenses_forecast.csv")
```

# Seasonal trends by license milestone?

So far we've explored time series seasonality for **ALL** business licensing activity. How about new/issued licenses? Renewed licenses?

## Data import

We can calculate how many days it takes to issue a license for an applicant by pulling in additional relational data.  Business licensing milestones are comprised of a “log” recording change of status for each business license or application by date/time and inspector.

```{r}
milestones <- read_csv("../data/raw/milestones.csv",
                       col_types = cols(
                         licenseno = col_character(),
                         addby = col_character(),
                         aplickey = col_character(),
                         statusdttm = col_datetime("%Y-%m-%d %H:%M:%S"),
                         code = col_character(),
                         load_date = col_datetime("%Y-%m-%d %H:%M:%S")
                       ))
```

## Exploratory data analysis

### Data cleanup

We can calculate the number of days it took to issue a business by subtracting the difference between the intake date and the issued date. Unfortunately, this calculation only works if we have the intake date in our milestones. Meaning that we won't know the "days to issue" for business licenses that were in the system before **August 2015**. 

```{r}
# Join the licenses dataframe with milesones
active_license_milestones <- active_licenses %>%
  left_join(milestones, by = c("licenseno"))

# Get a dataframe of license-milestones only only have an "Intake" milestone
active_license_milestones_intake <- active_license_milestones %>% 
  filter(code == "Intake")

# Get a dataframe of license-milestones which only have an "Issued" milestone
active_license_milestones_issued <- active_license_milestones %>% 
  filter(code == "Issued")

# Get a dataframe of license-milestones which only have an "Renewed" milestone
active_license_milestones_renewed <- active_license_milestones %>% 
  filter(code == "Renewed")

# Get the earliest intake statusdttm (process date) for each license
statusdttm_intake <- aggregate(
  active_license_milestones_intake$"statusdttm",
  by = list(active_license_milestones_intake$"licenseno"),
  min
)

# Get the earliest issued statusdttm (process date) for each license
statusdttm_issued <- aggregate(
  active_license_milestones_issued$"statusdttm",
  by = list(active_license_milestones_issued$"licenseno"),
  min
)

# Get the earliest renewed statusdttm (process date) for each license
statusdttm_renewed <- aggregate(
  active_license_milestones_renewed$"statusdttm",
  by = list(active_license_milestones_renewed$"licenseno"),
  min
)

active_license_milestone_summary <- active_licenses %>% 
  merge(statusdttm_intake, by.x = 1, by.y = 1, all.x = TRUE) %>%
  merge(statusdttm_issued, by.x = 1, by.y = 1, all.x = TRUE) %>%
  merge(statusdttm_renewed, by.x = 1, by.y = 1, all.x = TRUE) %>%
  mutate(days_to_issue = as.integer(round(difftime(x.y, x.x, units = "days")))) %>% 
  rename(date_intake = x.x, date_issued = x.y, date_renewed = x)

```

Export interim data

```{r}
write_csv(active_license_milestone_summary,
          "../data/interim/active_business_licenses_milestone_summary.csv",
          na = "")
```

How many observations do we have a "Days to Issue"" calculation for?

```{r}
active_license_milestone_summary %>%
  filter(!is.na(days_to_issue)) %>% 
  nrow()
```

What does the Days to Issue distribution look like?

```{r}
active_license_milestone_summary %>%
  filter(!is.na(days_to_issue)) %>%
  ggplot(aes(x = days_to_issue)) +
  geom_histogram(bins = 30, aes(fill = ..count..))
```

What are the average and median days to issue?

```{r}
active_license_milestone_summary %>% 
  filter(!is.na(days_to_issue)) %>% 
  summarise(count = n(),
            mean = round(mean(days_to_issue), 1),
            median = round(median(days_to_issue), 1),
            std_dev = round(sd(days_to_issue), 1),
            min = min(days_to_issue),
            max = max(days_to_issue))
```

How many "Intake", "Issued", and "Renewed" milestones do we have?


Number of licenses entered into the system (intake)
```{r}
active_license_milestone_summary %>%
  filter(!is.na(date_intake)) %>%
  count()
```

Number of licenses issued
```{r}
active_license_milestone_summary %>%
  filter(!is.na(date_issued)) %>% 
  count()
```

Number of licenses renewed
```{r}
active_license_milestone_summary %>%
  filter(!is.na(date_renewed)) %>% 
  count()
```

## Modeling

### Days to Issue

```{r}
daily_count <- active_license_milestone_summary %>%
  mutate(ds = as_date(date_issued)) %>%
  filter(ds >= analysis_date_start & ds <= analysis_date_end & !is.na(days_to_issue)) %>%
  group_by(ds) %>%
  summarise(y = mean(days_to_issue)) %>% 
  select(ds, y)
```

```{r}
m <- prophet(daily_count, weekly.seasonality = FALSE)
future <- make_future_dataframe(m, periods = 365)
forecast <- predict(m, future)
```

```{r}
plot_forecast(m,
              forecast,
              xlabel = 'Year',
              ylabel = "Average days to Issue")
```

```{r}
prophet_plot_components(m, forecast)
```

#### Export

```{r}
write_csv(daily_count, "../data/processed/days_to_issue_daily_count.csv")
write_csv(forecast, "../data/processed/days_to_issue_forecast.csv")
```

### Intake Licenses

```{r}
daily_count <- active_license_milestone_summary %>%
  df_daily_count(analysis_date_start, analysis_date_end, target_date = active_license_milestone_summary$date_intake)
```

```{r}
m <- prophet(daily_count, weekly.seasonality = FALSE)
future <- make_future_dataframe(m, periods = 365)
forecast <- predict(m, future)
```

Create a summary dataframe to compare 

```{r}
summary_df <- df_for_plotting(m, forecast) %>% 
  mutate(license_subset = "Intake")
```

```{r}
plot_forecast(m,
              forecast,
              xlabel = 'Year',
              ylabel = "Log Count")
```

```{r}
prophet_plot_components(m, forecast)
```

#### Export

```{r}
write_csv(daily_count, "../data/processed/intake_daily_count.csv")
write_csv(forecast, "../data/processed/intake_forecast.csv")
```

### Issued Licenses

```{r}
daily_count <- active_license_milestone_summary %>%
  df_daily_count(analysis_date_start, analysis_date_end, target_date = active_license_milestone_summary$date_issued)
```

```{r}
m <- prophet(daily_count, weekly.seasonality = FALSE)
future <- make_future_dataframe(m, periods = 365)
forecast <- predict(m, future)
```

Append to summary dataframe.
```{r}
plotting_df <- df_for_plotting(m, forecast) %>% 
  mutate(license_subset = "Issued")

summary_df <- summary_df %>%
  bind_rows(plotting_df)
```

```{r}
plot_forecast(m,
              forecast,
              xlabel = 'Year',
              ylabel = "Log Count")
```

```{r}
prophet_plot_components(m, forecast)
```

#### Export

```{r}
write_csv(daily_count, "../data/processed/issued_daily_count.csv")
write_csv(forecast, "../data/processed/issued_forecast.csv")
```

### Renewed Licenses

```{r}
daily_count <- active_license_milestone_summary %>%
  df_daily_count(analysis_date_start, analysis_date_end, target_date = active_license_milestone_summary$date_renewed)
```

```{r}
m <- prophet(daily_count, weekly.seasonality = FALSE)
future <- make_future_dataframe(m, periods = 365)
forecast <- predict(m, future)
```

Append to summary dataframe.
```{r}
plotting_df <- df_for_plotting(m, forecast) %>% 
  mutate(license_subset = "Renewed")

summary_df <- summary_df %>%
  bind_rows(plotting_df)
```

```{r}
plot_forecast(m,
              forecast,
              xlabel = 'Year',
              ylabel = "Log Count")
```

```{r}
prophet_plot_components(m, forecast)
```

#### Export

```{r}
write_csv(daily_count, "../data/processed/renewed_daily_count.csv")
write_csv(forecast, "../data/processed/renewed_forecast.csv")
```

## Summary

```{r}

summary_df %>%
  mutate(doy = strftime(ds, format = "2000-%m-%d")) %>%
  filter(license_subset != "days_to_issue") %>%
  group_by(doy, license_subset) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(doy = as_date(doy)) %>%
  arrange(doy) %>% 
  ggplot(aes(x = doy, y = yearly, color = license_subset)) +
    geom_line(na.rm = TRUE) +
    scale_x_date(date_breaks = "2 months", labels = scales::date_format('%B')) +
    labs(
      title = "Milestone Yearly Trend",
      subtitle = "Business licensing activity peaks at the beginning of the year and during summer months.",
      x = "",
      y = "Log Count",
      color = "Milestone")

ggsave("../figs/yearly_trend_summary.png")

```


